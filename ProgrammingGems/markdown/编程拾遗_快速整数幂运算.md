# 2022-09-04 编程拾遗：快速整数幂运算

## 整数幂运算

给定正整数 $a$ 和非负整数 $n$ ，求出 $a$ 的 $n$ 次方等于多少。
由于这个乘方通常较大（有可能超出计算机的整数表示范围），很多时候会同时给定一个整数 $m>=2$ ，求出 $a$ 的 $n$ 次方除以 $m$ 的余数是多少。
熟悉 Python 内置函数的同学们知道，这个问题就是如何实现整数版本的内置函数 `pow(a, n, m)` 。

## 朴素算法

最简单的方法是直接循环求解结果。Python 程序如下：

```python
def naive_pow(a, n, m):
    result = 1
    for i in range(0, n):
        result = result * a % m
    return result
```

这个方法的时间复杂度是 $O(n)$ 。

## 递归算法

上面的朴素算法复杂度是关于 $n$ 的线性函数，对于较大的 $n$ 来说很慢。
速度慢的原因是计算 $n$ 个 $a$ 的连乘的积的时候执行了每个乘法，我们可以采用分治的方法避免重复计算。

- 当 $n$ 为 $0$ 时，显然结果等于 $1$ 。
- 当 $n$ 为正偶数时，可以令 $n=2k$ ，其中 $k$ 是非负整数，则 $a^{n}=a^{2k}=(a^{k})^{2}$ 。
- 当 $n$ 为正奇数时，可以令 $n=2k+1$ ，其中 $k$ 是非负整数，则 $a^{n}=a^{2k+1}=a*(a^{k})^{2}$ 。

无论 $n$ 是偶数还是奇数，通过上述方法，每一步都可以将问题的规模减小一半，因此总时间复杂度是 $O(\log(n))$ 。

一个递归实现的 Python 程序如下：

```python
def recursive_pow(a, n, m):
    if n == 0:
        return 1
    r = recursive_pow(a, n // 2, m)
    r = r * r % m
    return r if n % 2 == 0 else r * a % m
```

这个递归算法可以快速计算 $n$ 比较小的结果，但当 $n$ 比较大时，很可能递归层数就超过了系统限制从而导致程序崩溃。

## 迭代算法

我们自底向上实现一个迭代算法，这里举例说明。

例如当 $n=18$ 时，其二进制表示 $10010$ 。
我们把它分解成 $2$ 的幂次之和，则 $18=16+2$ ，其中 $16=2^{4}, 2=2^{1}$ 对应二进制表示中相应 $1$ 的位置。
那么 $a^{18}=a^{16}*a^{2}$ 。
我们可以引入变量 $b$ 记住每一步运算时 $a$ 的相应幂次，即计算 $a$ 的 $1,2,4,8,16,\ldots$ 次幂，然后当 $n$ 的二进制表示对应位是 $1$ 的时候，把对应的 $b$ 乘到结果中。
迭代计算时，下一次的 $b$ 是当前 $b$ 的平方，例如 $a^{16}=(a^{8})^{2}$ 。

迭代实现的 Python 程序如下：

```python
def iterative_pow(a, n, m):
    b = a % m
    result = 1
    while n > 0:
        if n & 1 == 1:
            result = result * b % m
        b = b * b % m
        n = n >> 1
    return result
```

这个算法的时间复杂度也是 $O(\log(n))$ 。

